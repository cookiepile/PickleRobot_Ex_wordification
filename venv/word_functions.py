import re
import detectEnglish

# digit_map is a dictionary data type to map numbers with relative alphabets in mobile keypad notation
digit_map = {
    '2': 'ABC',
    '3': 'DEF',
    '4': 'GHI',
    '5': 'JKL',
    '6': 'MNO',
    '7': 'PQRS',
    '8': 'TUV',
    '9': 'WXYZ',
}

# letter_map is a dictionary data type to map alphabets with relative numbers in mobile keypad notation
letter_map = {
    ('A','B','C')     : '2',
    ('D','E','F')     : '3',
    ('G','H','I')     : '4',
    ('J','K','L')     : '5',
    ('M','N','O')     : '6',
    ('P','Q','R','S') : '7',
    ('T','U','V')     : '8',
    ('W','X','Y','Z') : '9',
}


# word_numbers function takes number as string input of phone number with delimeters removed and returns all possible combinations of 2 or more alhabet words that can be formed
# word_numbers('543') returns an array of size 45 combinations of alphabets represented by number input like ['JG', 'JH', 'JI', 'KG', 'KH', 'KI','KHF', 'KID', 'KIE'.... ]along with index in number input of the first alphabet of the word created

def word_numbers(input):
    # extracting only numbers
    number = input.replace('-', '')
    # removing delimiters from the phone number extracting only numbers
    #number = re.findall("\d+", input)
    #number = ''.join(number)
    
    # flag, flag2 used to offset single character words and empty string from array of combinations
    flag = 0
    
    # declare an empty list of final word combinations that have to be returned
    word_combinations = ['']
    
    # fixing index1(id1) to iterate till length-1 to not consider single alphabet as word
    for id1 in range(len(number) - 1):
        
        # declare empty list letter_Combinations to store n letter combinations in each loop of n
        letter_combinations = ['']
        
        temp = ['']
        flag2 = 0
        
        # second index (id2) iterating from next character from id1 to create combinations of 2 or more letter words till end of string
        for id2 in number[id1:len(number)]:

            # fetch alphabets represented by number from digit_map
            letters = digit_map.get(str(id2), '')
            
            # generate all combination from each alphabet in letters
            temp = [prefix + letter for prefix in temp for letter in letters]
            
            # check flag2 for single character word and empty string in case of 0 and 1 as input
            if flag2 < 2:
              letter_combinations = temp
            
            # start storing combinations of 2 and more letter words in each loop
            else:
              letter_combinations = letter_combinations + temp
            flag2 += 1

        # fill empty list word_combinations for the first iteration at flag=0
        if flag < 1:
          word_combinations = letter_combinations
          alphabet_index= [id1]*len(letter_combinations)
        
        # append letter combinations into the word_combinations list after flag set in more than 1 iterations
        else:
          word_combinations = word_combinations + letter_combinations
          alphabet_index = alphabet_index + [id1]*len(letter_combinations)
        
        flag += 1

    # create empty list words to store list of english words
    words = []
    
    # create empty list word_index to store index of wordified alphabet respective to the english word in words list
    word_index = []
    
    # iterate in all possible combinations to find english words
    for word in word_combinations:

        # detect is true when word in combinations list belongs to the english dictionary
        detect = detectEnglish.isEnglish(word)
        
        # if english word detected, append english word in the list of words
        if detect:
            words.append(word)
        
            # note index of the word in combinations list
            word_index.append(word_combinations.index(word))

    # words is a list of english words that can be generated by wordifying the input
    # word_index is a list of index of english word in the list of words
    # alphabet_index is a list of index in input of the first character of each word from word list
    return number,words,word_index,alphabet_index


# number_to_words function takes telephone number as input and returns wordified telephone number
def number_to_words(input):

    # number_without_hyphen is the input with all delimiters removed
    # words is a list of english words that can be generated by wordifying the input
    # word_index is a list of index of english word in the list of words
    # f_index is a list of index in input of the first character of each word from word list

    number_without_hyphen,words,word_index,f_index=word_numbers(input)

    # consider longest word from words list to replace numbers in the telephone number
    longest_word = max(words, key=len)

    # find index of the longest word to use while replacing relative number in telephone number
    longest_word_index = words.index(longest_word)

    # changing the index value to print to get into telephone number with hyphen format
    final_index = f_index[word_index[longest_word_index]]

    # replacing numbers in telephone number with their wordified version
    answer = str(number_without_hyphen[0:final_index]) + longest_word + number_without_hyphen[final_index-1 + len(longest_word) + 1:len(number_without_hyphen)]

    # create an empty list to store answer in phone number format
    answer_with_hyphen=[]

    # s_index is index of s in answer
    s_index=0

    # add each character from answer in wordified_phone_number and append hyphen at appropriate places
    for s in answer:
        answer_with_hyphen.append(s)
        if s_index==0 and (s.isdigit() or answer[s_index+1].isdigit()):
            answer_with_hyphen.append('-')
        if s_index==3 and (s.isdigit() or answer[s_index+1].isdigit()):
            answer_with_hyphen.append('-')
        if s_index== 6 and (s.isdigit() or answer[s_index+1].isdigit()):
            answer_with_hyphen.append('-')
        s_index += 1
    wordified_phone_number=''.join(answer_with_hyphen)

    return wordified_phone_number


# words_to_number function takes wordified telephone number as input and returns numbered telephone number
def words_to_number(input):

    # remove hyphen from the wordified telephone number
    without_hyphen=input.replace('-', '')

    # find index in the input of the first character
    for i in range(len(without_hyphen)):
        if without_hyphen[i].isalpha():
            final_index = i
            break

    # extract numbers from telephone number without hyphen
    original_numbers=''.join(re.findall("\d+", without_hyphen))

    # extract words from telephone number
    word = ''.join(re.findall("\D+", without_hyphen))

    # remove hyphen from the wordified_numbers
    #word_array = [c for c in wordified_numbers if c not in ' -']
    #word=''.join(word_array)

    # create array to store number converted from the wordified phone number
    converted_number = []

    # convert each character of word to number by mapping from dictionary letter_map
    for char in word:
        number = (next(v for k, v in letter_map.items() if char in k))
        converted_number.append(number)
    numbers = ''.join(converted_number)

    # combine the converted number with original_numbers from input and store in phone_number
    phone_number=original_numbers[0:final_index]+numbers[0:len(numbers)]+original_numbers[final_index:len(original_numbers)]

    # final_phone_number is the phone_number in telephone number format with hyphens
    final_phone_number=phone_number[0]+'-'+phone_number[1:4]+'-'+phone_number[4:7]+'-'+phone_number[7:11]
    return final_phone_number

# debug check
#print(words_to_number('1-232-324-923Z'))
